#  微服务

### 步骤

#### 约定 > 配置 > 编码

1、建module

2、改pom

3、写YML

4、主启动

5、业务类

RestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是

spring提供的用于访问Rest服务的**客户端模板**工具集

### Eureka

什么是服务治理？

什么是服务注册？

创建7001服务注册中心

修改pom文件

```java
<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
            <version>3.1.3</version>
</dependency>
```

写yml

```java
eureka:
  instance:
    hostname: 127.0.0.1  #eureka服务实例名称
  client:
    #false表示不向注册中心注册自己
    register-with-eurka: false
    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    fetch-register: false
    service-url:
        #设置与eureka server交互的地址查询服务和注册服务都需要依赖的地址
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka
#         defaultZone: http://127.0.0.1:7001/eureka
```

主启动

```java
@EnableEurekaServer
```

服务提供者8001

修改pom文件

```java
<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
            <version>3.1.3</version>
</dependency>
```

写yml

```java
eureka:
  client:
    #false表示不向注册中心注册自己
    register-with-eurka: true
    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    fetch-register: true
    service-url:
        #设置与eureka server交互的地址查询服务和注册服务都需要依赖的地址
      defaultZone: http://127.0.0.1:7001/eureka
```

主启动

```java
@EnableEurekaClient
```

服务消费者80

修改pom文件

```java
<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
            <version>3.1.3</version>
</dependency>
```

写yml

```java
eureka:
  client:
    #false表示不向注册中心注册自己
    register-with-eurka: true
    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    fetch-register: true
    service-url:
        #设置与eureka server交互的地址查询服务和注册服务都需要依赖的地址
      defaultZone: http://127.0.0.1:7001/eureka
```

主启动

```java
@EnableEurekaClient
```

#### 集群版

单机指向自己，集群指向别人

在8001和8002中相互守望，相互调用，在c:...hosts下进行映射

在80中将地址绑定微服务的暴露名称，并且在RestTempt上进行@LoadBalanced负载均衡能力

### actuator配置：

pom中spring-boot-starter-web和spring-boot-starter-actuator标配

在8001yml中

```java
instance:
	instance-id: payment8001
```

ip提示：

```java
instance:
	instance-id: payment8001
    prefer-ip-address: true
```

#### 服务发现Discovery

对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息

8001Controller端口

```java
@Autowired
    private DiscoveryClient discoveryClient;
```

编写接口

```java
//服务发现
    @GetMapping("/payment/discovery")
    public Object discovery(){
        //所有服务
        List<String> services = discoveryClient.getServices();
        for (String element : services){
            log.info("+++++++element:"+ element);
        }
        //一个服务下的所有实例
        List<ServiceInstance> instances = discoveryClient.getInstances("cloud-payment-service");
        return this.discoveryClient;
    }
```

主启动

```java
@EnableDiscoveryClient
```

#### eureka自我保护

AP形式：某时刻微服务不可用的时候，不会立刻清除

##### 怎么禁止自我保护

在7001注册yml上

```java
  Server:
#    关闭自我保护机制，保证不可用服务及时剔除
    enable-self-preservation: false
```

8001上

```java
 instance:
    #    eureka客户端向服务端发送心跳的时间间隔，单位为秒（默认30秒）
    lease-renewal-interval-in-seconds: 1
#    eureka服务端在收到最后一次心跳后等待时间上限，单位为秒（默认90秒），超时将剔除
    lease-expiration-duration-in-seconds: 2
```

### 注册中心zookeeper

下载安装

#### 服务提供者

建moudel，cloud-provider-payment8004

改pom

```java
    <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-zookeeper-discovery -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>
            <version>3.1.2</version>
        </dependency>
```

改yml

```java
spring:
  application:
    name: cloud-provider-payment
  cloud:
    zookeeper:
      connect-string: 192.15.111.144
```

主启动类

```java
@SpringBootApplication
@EnableDiscoveryClient
public class PaymentMain8004 {
    public static void main(String[] args) {
        SpringApplication.run(PaymentMain8004.class,args);
    }
}
```

业务类

```java
    @RequestMapping("/paymet/zk")
    public String paymentzk(){
        return "springcloud with zookeeper:"+serverPort ;
```

zookeeper是cp格式临时节点

#### 服务消费者 



### Consul

一套开源的分布式服务发现和配置管理系统，由HashiCorp公司用Go语言开发，提供了微服务系统中的服务治理、配置中心、控制总线等功能，这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之consul提供了一种完整的服务网格解决方案。

1、下载安装

2、建moudul

3、改pom

    <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-zookeeper-discovery -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-Consul-discovery</artifactId>
            <version>3.1.2</version>
        </dependency>
4】改yml

```java
server:
	port:
		8006
Spring:
	application:
		name: consul-provider-payment
    cloud:
		consul:
			host: localhost
			port: 8500
            discovery:
				service-name:${spring.application.name}
```

主启动类

```java
@SpringBootApplication
@EnableDiscoveryClient
public class PaymentMain8004 {
    public static void main(String[] args) {
        SpringApplication.run(PaymentMain8004.class,args);
    }
}
```



### 负载均衡服务调用Ribbon

是基于Netflix Ribbon实现的一套客户端，负载均衡工具

Ribbon本地负载均衡 VS nginx服务端负载均衡

Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求，即负载均衡由服务端实现的

Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存在jVM本地，从而本地实现RPC远程服务调用技术

###### 引入eureka可以直接使用

restTemplit：

​	getForObject：返回对象为响应体中数据转化成的对象，基本上可以理解为json

​	getForEntity：返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、相应状态码、响应体等

### 负载均衡演示：

IRule接口：包含了很多负载均衡算法

com.netfix.loadbalancer.RoundRobinRule：轮询

com.netfix.loadbalancer.RandomRule: 随机

com.netfix.loadbalancer.RetryRule: 先按照RoundRobinRule的策略获取服务，如果服务获取失败则在指定时间内进行重试，获取可用的服务

weightedResponseTimeRule: 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择

BestAvailableRule:会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务

AvailabilityFilteringRule：先过滤故障实例，在选择并发较小的实例

ZoneAvoidanceRule：默认规则，复合判断server所在区域的性能和server的可用性选择服务器

#### 如何替换

官方文档警告，自定义的配置类不能放在@ComponentScan所扫描的当前包及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端多共享，达不到特殊定制的目的了

1新建package

2、新建配置类

3、主启动

```java
@RibbonClient(name="CLOUD-PAYMENT-SERVICE",configuration=MySelfRule.class)
```

### OpenFeign

我们只需要创建一个接口并使用注解的方式来配置它（在一个微服务接口上面标注一个Feign注解即可）

在消费方使用

1、接口加注解

service服务方和调用方相吻合的接口+@FeignClient

2、yml

使用eureka不变

3、主启动

```java
@EnableFeignClients
```

4、接口业务上

```
//掉那个服务就写那个服务名称
@FeignClient("CLOUD-PAYMENT-SERVICE")
@Component
public interface PaymentFeignService {
@GetMapping("/Feign/all")
    List<SysUser> selectUser();
}
```

5、controller

```
@RestController
public class FeignController {

    @Autowired
    private PaymentFeignService paymentFeignService;

    @GetMapping("/consumer/selectUser")
    @ApiOperation(value = "查询用户")
    public List<SysUser> selectConsumerUser() {
        return paymentFeignService.selectUser();
    }
}
```

### OpenFeign超时控制

yml中开启自定义配置

```java
ribbon:
#建立连接后从服务器读取到可用资源所用的时间
	readTimeOut: 5000
        #指的是建立连接所用的时间，适用于网络状况正常的情况下，两端连接所用的时间
    ConnectTimeout:5000
```

#### OpenFeign日志打印

类别：

​	NONE：默认的，不显示任何日志

​	BASIC：仅记录请求方法，URL，响应状态码及执行时间

​	HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息

​	FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据

### 服务降级Hystrix（豪猪哥）

是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等，hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性

断路器本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似保险丝），项调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要的占用，从而避免了故障在分布式系统中蔓延，乃至雪崩

服务降级（fallback）：有一个兜底（程序运行异常、超时、服务熔断出发服务降级、线程池/信号量打满也会导致服务降级）

服务熔断：访问服务最大，直接拒绝，调用服务降级并返回友好提示

服务限流：秒杀高并发等操作，大家排队，有序进行

###### 服务降级

客户端和服务端都可以，一般放客户端

在业务类上添加

```java
@HystrixCommand(fallbackMethod="XXXXXXXXXX",commandProperties={@HystrixProperty(name="execution.isolation.thread.timeoutInMilliseconds",value="3000")})     兜底类
```

主启动类

```java
@EnableCircuitBreaker
```

在客户端80上yml

```java
feign:
	hystrix:
		enabled: true
```

著启动

```java
@EableHystrix
```

feign接口@DefaultProperties（defaultFallback=” “）//没有指明的就走通用的

##### 服务熔断

```java
@HystrixCommand(fallbackMethod = "paymentCircuitBreaker_fallback",commandProperties={
    @HystrixProperty(name ="ciruitBreaker.enabled",value="true"),//是否开启断路器
     @HystrixProperty(name ="ciruitBreaker.requestVolumeThreshold",value="10"),//请求次数
     @HystrixProperty(name ="ciruitBreaker.sleepWindowInMilliseconds",value="1000"),//时间窗口期
     @HystrixProperty(name ="ciruitBreaker.errorThresholdPercentage",value="30"),//失败率达到多少后跳闸
})
```

### 服务网关  gateway

https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#configuring-route-predicate-factories-and-gateway-filter-factories

目标提供统一的路由方式且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/指标，限流

动态路由：能够匹配任何请求属性，可以对路由指定Predicate（断言）和Filter（过滤器）；集成Hystrix的断路器的功能；继承SpringCloud服务发现功能；易于编写的Predicate（断言）和Filter（过滤器）；请求限流功能；支持路径重写

路由：是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由

Predicate断言：参考的是java8的java.util.function.Predicate开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数）如果请求与断言相匹配则进行路由

Filter：使用过滤器，可以在请求被路由前或者之后对请求进行修改

1、建modul

2、改pom

3、写yml

4、业务类（不需要看大门的）

5、新增gateWay配置

```java
Spring:
	application:
		name: cloud-gateWay
    cloud:
		gateway:
			routes:
				-id: payment_routh       #路由的id，没有固定规则但要求唯一，建议配合服务名
                 uri: http://localhost:8001    #匹配后提供的服务的路由地址
				predicates:
						-path=/payment/get/**   #断言，路径相匹配的进行路由 
				-id: payment_routh2
                 uri: http://localhost:8001
				predicates:
						-path=/payment/lb/**	
```

gateway开启动态路由的实例

```java
Spring:
	application:
		name: cloud-gateWay
    cloud:
		gateway:
			discovery:
				locator:
					enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由
			routes:
				-id: payment_routh       #路由的id，没有固定规则但要求唯一，建议配合服务名
                 #uri: http://localhost:8001    #匹配后提供的服务的路由地址
				uri:lb://cloud-payment-service   #动态匹配后提供服务的路由地址
				predicates:
						-path=/payment/get/**   #断言，路径相匹配的进行路由 
				-id: payment_routh2
                 uri: http://localhost:8001
				predicates:
						-path=/payment/lb/**	
```

可用的Route Predicate：

1、After Route Predicate:

```java
predicates:
	-path=/payment/get/**   #断言，路径相匹配的进行路由 
	-After=2017-01-20T17:42:47.789-07:00[Asia/Shanghai]这个时间之后
```

2、Before Route Predicate

3、Between Route Predicate

4、Cookie Route Predicate

```java
predicates:
	-path=/payment/get/**   #断言，路径相匹配的进行路由 
	-Cookie=username,zzyy   #
```

5、Header Route Predicate

6、Host Route Predicate

7、Method Route Predicate

8、Path Route Predicate

9、Query Route Predicate













